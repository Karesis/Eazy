# EazyLanguage LLVM Compiler

## Project Overview

**EazyLanguage** is an experimental programming language designed for learning and exploring compiler construction principles. This project provides a compiler that translates EazyLanguage source code (`.ez` files) into LLVM Intermediate Representation (IR), which is then compiled into native executables.

The compiler is written in Python and utilizes ANTLR for parsing and `llvmlite` for LLVM IR generation. It serves as a practical implementation of a compiler for a custom language.

## Core Concepts of EazyLanguage (Current Version)

The current version of EazyLanguage supports the following core features:

* **Variable Declaration:** Integer variables are declared using the `int` keyword (e.g., `int myVariable`).
* **Assignment:** Variables are assigned values using the `=` operator (e.g., `myVariable = 10 + 5`).
* **Expressions:**
    * Arithmetic: `+`, `-`, `*`, `/` with standard precedence (multiplication/division before addition/subtraction).
    * Relational: `>`, `<`, `==` for comparisons, primarily used in conditional statements.
    * Literals: Integer numbers (e.g., `123`).
    * Identifiers: Variable names.
    * Parentheses: `()` for grouping expressions.
    * Unary Minus: e.g. `-5`.
* **Print Statement:** Outputs the value of an expression to the console (e.g., `print myExpression`).
* **Labels:** Define points in code that can be targeted by `goto` (e.g., `myLabel:`).
* **Conditional Goto:** `if condition goto label` provides basic conditional branching. The condition evaluates to true if non-zero, false if zero.
* **Line-based Structure:** Statements are generally expected to be one per line, terminated by a newline.
* **Comments:** Single-line comments start with `#`.

*(Note: This version significantly differs from previous EazyLanguage concepts like block-based scoping with `@name:`, `image`, `call` for block execution, and explicit heap-allocated `struct`s. Those features are not part of the current LLVM-based compiler.)*

## Current Compiler Status

* **Compiler Pipeline:**
    1.  EazyLanguage source code (`.ez`) is parsed by an ANTLR-generated parser.
    2.  A custom Visitor (`MyEazyTreeWalker` in `EazyLanguageCompiler.py`) traverses the parse tree and generates LLVM IR using the `llvmlite` library.
    3.  The generated LLVM IR (`.ll` file) can be optionally saved.
    4.  The LLVM IR is then compiled to an assembly file (`.s`) using `llc`.
    5.  Finally, the assembly file is compiled and linked into a native executable using a C compiler (`clang` or `gcc`).
* **Frontend (ANTLR):**
    * The language grammar is defined in `EazyLanguage.g4`.
    * Python lexer, parser, visitor, and listener base classes are generated by ANTLR into the `EazyLepaser/` directory.
* **IR Generation (Python Visitor with `llvmlite`):**
    * Handles variable declarations (`alloca`).
    * Handles assignments (`load` for RHS variables, `store` to LHS variable's memory).
    * Generates LLVM instructions for arithmetic (`+`, `-`, `*`, `sdiv`) and relational (`icmp sgt`, `icmp slt`, `icmp eq`) operations.
    * Implements `print` statements by generating calls to an external `printf` C library function.
    * Implements `if condition goto label` using LLVM basic blocks and conditional/unconditional branch instructions (`br i1...`, `br label...`).
    * Manages labels by mapping them to LLVM basic blocks.
* **Main Compiler Script (`EazyLanguageCompiler.py`):**
    * Orchestrates the lexing, parsing, LLVM IR generation, and optional compilation to assembly and executable.
    * Provides command-line options for specifying input/output files and controlling compilation stages.

## Project Structure

```

.
├── EazyLanguage.g4            \# ANTLR grammar file for EazyLanguage
├── EazyLanguageCompiler.py    \# Main Python script for the compiler
├── EazyLepaser/               \# Directory for ANTLR-generated Python files
│   ├── EazyLanguageLexer.py
│   ├── EazyLanguageParser.py
│   ├── EazyLanguageVisitor.py
│   ├── EazyLanguageListener.py
│   ├── EazyLanguage.tokens
│   └── ... (other generated files like .interp, **pycache**)
├── examples/                  \# Directory for EazyLanguage (.ez) example source files
│   └── test.ez                \# (or test\_control\_flow.ez, simplist.ez)
├── .gitignore                 \# Specifies intentionally untracked files
└── README.md                  \# This file

# Potentially also:

# requirements.txt             \# Python package dependencies

# output\_files/                \# Directory for .ll, .s, or executable outputs (if redirected)

````

## How to Run

### Prerequisites

1.  **Python 3:** (e.g., Python 3.8 or newer).
2.  **ANTLR 4 Tool:** The ANTLR Java binary (`antlr-4.x.x-complete.jar`) is needed if you modify `EazyLanguage.g4` and need to regenerate the parser files in `EazyLepaser/`. (Make sure you know how to run it, e.g., via an alias or `java -jar ...`).
3.  **Python Packages:** Install the required Python libraries using pip (preferably in a virtual environment):
    ```bash
    pip install antlr4-python3-runtime llvmlite
    ```
4.  **LLVM Toolchain:** You need `llc` (LLVM static compiler) and a C compiler like `clang` or `gcc`. On Ubuntu/Debian, you can install them via:
    ```bash
    sudo apt update
    sudo apt install llvm llvm-runtime gcc # or clang
    ```

### Compiling EazyLanguage Code

Use the `EazyLanguageCompiler.py` script. Here are some examples (assuming your EazyLanguage source file is `examples/test.ez`):

1.  **Compile to an executable (default):**
    ```bash
    python EazyLanguageCompiler.py examples/test.ez 
    ```
    This will typically produce an executable named `test` (or `a.out` if `test.ez` was the only argument and no `-o` was given for a basename) in the current directory. Intermediate files (`.temp.ll`, `.temp.s`) might also be created.

2.  **Specify output executable name:**
    ```bash
    python EazyLanguageCompiler.py examples/test.ez -o myprogram
    ```
    This will produce an executable named `myprogram`.

3.  **Generate LLVM IR only:**
    ```bash
    python EazyLanguageCompiler.py examples/test.ez --emit-llvm 
    ```
    This will produce `test.ll` (or `examples/test.ll` depending on path logic in script).
    ```bash
    python EazyLanguageCompiler.py examples/test.ez --emit-llvm -o output/mycode.ll
    ```
    This will produce `output/mycode.ll`.

4.  **Generate Assembly only:**
    ```bash
    python EazyLanguageCompiler.py examples/test.ez -S
    ```
    This will produce `test.s` (and an intermediate `.temp.ll`).
    ```bash
    python EazyLanguageCompiler.py examples/test.ez -S -o output/mycode.s
    ```
    This will produce `output/mycode.s`.

### Running the Executable
Once an executable is generated (e.g., `myprogram`):
```bash
./myprogram
````

## Future Plans / Limitations

  * **Semantic Analysis:**
      * Implement checks for undeclared variables before use (currently prints an error during IR generation but doesn't stop).
      * Validate `goto` targets (ensure labels are defined).
      * (If more types are added) Implement type checking for expressions and assignments.
  * **Language Features to Add/Improve:**
      * More data types (e.g., floats, booleans, strings).
      * Structured loop constructs (e.g., `while` or `loop`).
      * Function/procedure definition and calls.
      * Arrays or other collection types.
      * (Revisit) The "Block" concept from earlier EazyLanguage designs, if desired, and how it maps to LLVM.
  * **Compiler Enhancements:**
      * More robust error reporting with source line numbers and details.
      * Integration of LLVM optimization passes (using `opt` or `llvmlite` bindings if available).
      * Option to automatically clean up intermediate files (`.temp.ll`, `.temp.s`).
  * **Memory Management:** (Currently only stack allocation for `int` via `alloca`). If heap allocation is introduced (e.g., for strings, arrays, or user-defined structs), memory management (manual or GC) would be a consideration.

## License

This project is licensed under the [Apache License 2.0](./LICENSE).
