eazy的具体语法：

1.块
一个块由许多子块组成。
@(父块)块名(入块参数):
    xxx...
比如
@add(int a, int b):
    int result 
    result = a + b
    .result # 块绑定，具体看后面
入块参数不能为空，如果的确不需要，则写成
@add:这样，也就是没有()。

程序入口块（主块）:
@__main__:
# 后面跟代码。
程序入口，由语言本身实现和占用的一个块。
匿名块：没有命名的块。
如
int a
int b
这是两个用于声明变量的块。
由于没有名字，所以无法成为goto的对象。
普通命名块（也就是普通的有名字的块）：

int i
i = 5
begin:
    if i > 0
    goto dimi
    goto end
dimi:
    i -= 1
    goto begin
end:
    print i # 这里假设有一个能print的东西，只是为了演示

这里begin, dimi, end 就是这种普通的块，语句在没有goto的时候会自然的穿过这种块，执行后面的语句。
普通的块共享作用域。
特殊的块：（还没有想好怎么命名来区分）
带有@的块，使得块内部和外部作用域隔离。
goto只能作用于“相邻的”普通命名块

@here:
    hahaha:
        goto end # 可行
    end:
        goto hello # 出错！
    @hello:
        goto there # 出错！
    goto there #也出错！
@there:

块的绑定和制作：
@块用于“制作”一个结构体，调用块的时候得到的是一个这样的结构体的“镜像”，块是这个结构体制作的一份说明。

@Point(int x, int y):
    .x
    .y
@__main__:
    int a
    int b
    a = 5
    b = 8
    point = Point(a, b)
    print(point.a)
    print(point.b)
    # 同上，假设有print这么一个东西

首先：point = Point(a, b)会把a和b按照入块参数对应分别赋给x和y，然后.x表示将x和块Point绑定，.y同理，然后块结束，得到一个结构体{int:x, int:y}, 里面第一个位置为5，第二个位置为8，然后point是这个结构体的名字。（x是第一个位置的名字，y是第二个）

更多有关结构体的说明在结构体中讲解。
块支持内嵌，内嵌的块和其“父块”作用域共通。
@A:
    int a
    a = 4
    @B:
        int b
        b = a + 3
        int return
        return = b + a
        .return
    c = B
    print(c.return) # 输出11

但是假设不制作B（上面就是c = B），那么B内部的所有东西都会被“忽视”
之前使用过的术语：镜像，会能更好理解这种“块调用”的行为

块天然支持并发。但是目前暂时不做拓展。

del ：一个强大的关键字，用于继承。目前关于继承就是简单的把块名字写在块前，比如
@(father)name: 这样，然后行为就是把父块“复制”到这里。而假设父块有入块参数，则会要求
@(father(args...))name: 可以理解为python的super和继承的一种结合。然后由于块的本质是一个结构体，从父块继承来的结构体可以做调整：使用del 语句来删除不想要的。
比如：
@father(int x)
    .x
    int y = x + 5
    .y

@(father(6))son:
    print(x) # 6
    print(y) # 11
    del x
    # print(x) # Error!!
    int z = y * 2
    .z
# -> {int: y, int: z} , y = 11, z = 22
(关于结构体，具体见下文）
2.结构体

结构体的定义很简单，就是一组简单的数据的整合。
用{}括起来的东西就是结构体。比如：
{int, int} a
意思可以解释为“a是一个有两个int的普通变量”
可以对比：
int a
访问与赋值：使用[]
比如
a[0] = 2
a[1] = 5
a[2] = 5 # 报错！
当然还可以
{int, char} b
如果想复用，可以使用def (def 在eazy中比较重要，用于宏定义）
def {int, int} Point
Point A # 也就是{int, int} A

别名：为了方便的获取和使用结构体，可以为每一个位置起一个名字。
{int:x, int:y} A

这样就可以用A.x来访问A[0]
使用A[0]直接访问也是可行的。
结构体的预处理：在早期的语法中使用，但是现在被统一到块中。
(可以认为块就是带有预处理的结构体。)
当然，你也可以这样：
{int: x, int} B
只是不是很推荐。

复定义块：假设你想定义一个数组，
{int, int, int, int, int, ......这样太麻烦了！
可以使用int[10]来快速定义。比如：
int[10] a
char[10] b

如果你还想给每个位置都起个名字，请使用块而不是直接定义。

3.字符串：
在之前说过，统一用""表示，不区分单个还是多个（没有单个字符的概念，只有单个字符的字符串的概念），默认是可变的。（使用const修饰来防止改变）
比如
char[5] = "hello"
const char[6] = "hello\0" # 你喜欢的用于标记尾部的符号，这里使用C语言风格的\0

4.宏：（这个板块还待完善）
普通定义：
def A B
和C的 #define差不多
常用于定义结构体：
def {结构体} 名称
比如def {int, int} Point
这样之后所有写Point的地方就等同于写{int, int}
def 1000 max
那么写max地方就会被换成1000。
注意：def的本质是纯粹的文本替换。不是像C语言里的typedef那样。
函数宏：
高级宏：
ast宏：（类似于lisp语言的宏）
待完善。

5.条件与判断
if, elif, else 都只会作用于后面的一条紧跟的语句，所以常见的形式就是使用goto来和if配合。
